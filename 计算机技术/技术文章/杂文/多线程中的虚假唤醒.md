当一个正在等待条件变量的线程由于条件变量被触发而唤醒时，却发现它等待的条件（共享数据）没有满足

避免虚假唤醒，就不应该采用 if 条件判断，而应该采用 while 循环判断

这样，即便生产者唤醒所有消费者，由于消费者这边采用 while 循环判断，确保`wait`方法会在唤醒后重新检查条件，哪怕g_deque中已经没有可消费对象，也不会导致这边出现虚假唤醒

如果消费者这边采用 if 条件判断，由于生产者唤醒，消费者接收到信号不重新检查g_deque中是否还有可消费对象（有可能已经被其它消费者消费），导致可能出现虚假唤醒

```c++
// 虚假唤醒

if (g_deque.empty())
{
    g_cond.wait(lck);
}

// 避免虚假唤醒

while (g_deque.empty())
{
    g_cond.wait(lck);
}
```

还有通过Lambda表达式，同样可以避免虚假唤醒

即在wait方法的第二个参数提供Lambda表达式，如果返回值为true就获取锁往下执行代码

```c++
g_cond.wait(lock, []{ return !g_deque.empty(); });
```



如上两种写法的产生，就是C++11提供wait的两种方法的参数列表不同

```c++
void wait (unique_lock<mutex>& lck);

template <class Predicate>  
void wait (unique_lock<mutex>& lck, Predicate pred);
```

其中 pred 代表一个可调用的对象或函数，它不接受任何参数，并返回一个可以计算为 `bool` 的值。 这将被反复调用，直到它的计算结果为 `true`






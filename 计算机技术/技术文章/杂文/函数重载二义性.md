函数名相同，参数列表不同，与返回值无关，即为函数重载

函数重载的二义性就出现在参数列表中，下面看看哪些情况导致二义性（这里不讨论模板编程的情况）

## 默认参数

```c++
void g(int, int = 0);

void g(int);
```

默认参数意味着可以不用填写，上面两个函数在你只填写第一个参数情况下，对于函数调用就难以区分你究竟要调用哪个函数了

所以尽量不要用默认参数，除非你明确能让程序知道调用哪个函数

## 隐式类型转换

```c++
void f(int);
void f(double);

f(1.0f); // float 可以转换为 int 或 double，编译器无法决定
```

使用 **explicit** 关键字可以**阻止构造函数**的隐式类型转换，只需要在函数返回值前面添加即可

除构造函数以外，只能用显示转换来解决隐式转换问题

```c++
f(static_cast<double>(1.0f)); // 明确调用 f(double)
```

## 基类和派生类成员函数同名

```c++
class Base {
 public:
  void i(int);
};

class Derived : public Base {
 public:
  void i(int);
};


int main(){
  Derived obj;
  obj.i(10); // 调用 Base::i(int) 还是 Derived::i(int)？
  return 0;
}
```

我们绝不能让基类和派生类函数重名，除非你在基类将该函数设为虚函数，也就能利用虚函数表确定调用哪个具体的函数了

此时，派生类和基类该函数名相同情况下视为重写

## 指针和引用

当重载函数包含指针或引用参数，并且存在类型转换时，可能会导致二义性，因为非 `const` 类型的指针或引用可以转换为 `const` 类型

我想这应该归类到隐式转换，但这点容易被忽视，也就单独拎出来说了

```c++
void j(int*);
void j(const int*);

int x = 0;
const int y = 0;

j(&x); // 调用 j(int*) 还是 j(const int*)？
j(&y); // 调用 j(int*) 还是 j(const int*)？
```

